::

  F=foo.mp4
  test_f_1()
  {
    /usr/bin/time -p mplayer "$F" -endpos 60 -quiet -untimed -no-audio -vo null "$@" 2>&1 >/dev/null | tail -n 3 | head -n 1 | cut -d ' ' -f 2
  }
  test_f()
  {
    echo -n "$1: "
    shift
    for t in 1 2 3; do test_f_1 "$@"; done | sort -n | head -n 3 | tail -n 1
  }
  test_f "No filter"
  test_f "eq2"       -vf eq2=1:-1
  test_f "lua"       -vf lua=:'1-p(x\,y)'::
  test_f "dlopen"    -vf dlopen=./invert_y.so
  test_f "geq"       -vf geq='255-p(X\,Y)':'p(X\,Y)':'p(X\,Y)'

Input file "$F"::

  Detected file format: Matroska
  [stream] Video (+) --vid=0 'Episode 01' (avc1/V_MPEG4/ISO/AVC)
  [stream] Audio (+) --aid=0 --alang=eng (*) 'AC3 2.0' (0x2000/A_AC3)
  [stream] Audio     --aid=1 --alang=jpn 'FLAC 2.0' (fLaC/A_FLAC)
  [stream] Subs  (+) --sid=0 --slang=eng (*) 'Signs/Songs' (ASS/S_TEXT/ASS)
  [stream] Subs      --sid=1 --slang=jpn 'Dialogue' (ASS/S_TEXT/ASS)
  [V] filefmt:18  fourcc:0x31637661  size:1280x720  fps:23.976  ftime:=0.0417
  [ass] auto-open
  Opening video filter: [screenshot]
  Selected video codec: H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 [libavcodec]
  Selected audio codec: ATSC A/52A (AC-3) [libavcodec]
  AO: [alsa] 48000Hz 2ch s16le (2 bytes per sample)
  VO: [xv] 1280x720 => 1280x720 yv12 

Results::

  No filter: 5.98
  eq2: 6.26
  lua: 20.20
  dlopen: 6.41
  geq: 146.75

Results (by wm4, running LuaJIT 2.0.0-beta9)::

  No filter: 7.65
  eq2: 8.22
  lua: 11.76

invert_y.c::

  #include <assert.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  
  #include "vf_dlopen.h"
  #include "filterutils.h"
  
  /*
   * luma inverter
   *
   * usage: -vf dlopen=./invert_y.so
   *
   * inverts the luma plane. Duh.
   */
  
  static void invert_plane(
      unsigned char *dest, unsigned dest_stride,
      const unsigned char *src, unsigned src_stride,
      unsigned length,
      unsigned rows
      )
  {
      unsigned i, j;
      assert(dest_stride >= length);
      assert(src_stride >= length);
      for (i = 0; i < rows; ++i)
      {
          const unsigned char *s = &src[src_stride * i];
          unsigned char *d = &dest[dest_stride * i];
          for (j = 0; j < length; ++j)
              *d++ = *s++ ^ 0xFF;
      }
  }
  
  static int iy_put_image(struct vf_dlopen_context *ctx)
  {
      unsigned int p;
  
      assert(ctx->inpic.planes == ctx->outpic->planes);
  
      for (p = 0; p < ctx->outpic->planes; ++p) {
          assert(ctx->inpic.planewidth[p] == ctx->outpic->planewidth[p]);
          assert(ctx->inpic.planeheight[p] == ctx->outpic->planeheight[p]);
      }
  
      invert_plane(
              ctx->outpic->plane[0], ctx->outpic->planestride[0],
              ctx->inpic.plane[0], ctx->inpic.planestride[0],
              ctx->inpic.planewidth[0], ctx->inpic.planeheight[0]
          );
      for (p = 1; p < ctx->outpic->planes; ++p) {
          copy_plane(
                  ctx->outpic->plane[p], ctx->outpic->planestride[p],
                  ctx->inpic.plane[p], ctx->inpic.planestride[p],
                  ctx->inpic.planewidth[p], ctx->inpic.planeheight[p]
              );
      }
  
      ctx->outpic->pts = ctx->inpic.pts;
      return 1;
  }
  
  int vf_dlopen_getcontext(struct vf_dlopen_context *ctx, int argc, const char **argv)
  {
      VF_DLOPEN_CHECK_VERSION(ctx);
      (void) argc;
      (void) argv;
      static struct vf_dlopen_formatpair map[] = {
          { "yv12", "yv12" },
          { NULL, NULL }
      };
      ctx->format_mapping = map;
      ctx->put_image = iy_put_image;
      return 1;
  }
